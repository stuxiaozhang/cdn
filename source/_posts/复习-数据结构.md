---
layout: pages
title: 数据结构常见面试问题
date: 2020-09-28 18:51:58
tags: 
- 计算机基础
- 数据结构
index_img: /img/star2.png
---





 {% note warning %} 

2020.09.28：总结了一些有关数据结构的常见面试问题以及一些书上知识点。

 {% endnote %} 



## 常见面试问题

### 大O什么意思？

大O表示法：算法的时间复杂度通常用 <u>大O符号</u> 表述，定义为 $T[n] = O(f(n)) $。称函数 T(n)以f(n)为界或者称T(n)受限于f(n)。 如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”。

![](/img/ds/1.jpg)



### 简述数据结构的三要素

- 逻辑结构：从逻辑上描述数据，即数据之间的逻辑关系。（线性结构和非线性结构）
- 物理结构：数据在计算机内的存储方式（顺序存储，链式存储，索引存储，散列存储）
- 数据的运算：数据的运算包括数据的定义与实现，运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。



### 循环比递归效率高吗？

并不能绝对的说循环比递归效率高。

递归的优点是：代码简洁清晰，容易检查代码的正确性。缺点是：当递归调用的次数很多时，对执行效率会有一定的影响。

循环的优点是：结构简单，速度快；缺点是：并不能解决所有问题，有些问题适合用递归来解决而不适合用循环。



### 循环比递归效率高吗？

并不能绝对的说循环比递归效率高。

递归：

- 优点：代码简洁清晰，容易检查代码的正确性。
- 缺点：当递归调用的次数很多时，对执行效率会有一定的影响。

循环：

- 优点：结构简单，速度快
- 缺点是：并不能解决所有问题，有些问题适合用递归来解决而不适合用循环。





### 栈和队列的区别

队列和栈都是操作受限的线性表。

队列是只允许在一段插入，在另一端删除的线性表。进入队列的元素按先入先出的原则进行处理；

栈是指能在表尾进行插入和删操作的线性表。对于插入到栈的元素按先进后出的规则进行处理，插入和删除操作都在栈顶进行。



### 共享栈

利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底设在共享空间的两端，两个栈顶向共享空间的中间延伸，这样能够更有效的利用存储空间。



### KMP算法

思想：如果已匹配相等的前缀序列中有某个后缀正好是子串的前缀，就可以将子串向后滑动到与这些后缀相匹配的位置。

![](/img/ds/kmp.jpg)





### 名词解释：满二叉树，完全二叉树，二叉排序树，平衡二叉树。

- 满二叉树：高度为H，结点数为 $2^{H}-1$ 的二叉树为满二叉树。
- 完全二叉树：除最后一层外，其余各层的节点数量达到最大值，并且最后一层只能在右侧缺少节点。
- 二叉排序树：左子树上所有的关键字均小于根结点，右子树上所有关键字均大于根结点。左子树和右子树又分别是一棵二叉排序树。
- 平衡二叉树：树中每一个结点的左子树，右子树高度之差的绝对值小于等于1





### 二叉树的存储结构

- 顺序存储：用一组连续的地址单元自上到下，自左到右的存储完全二叉树的结点元素。

- 链式存储：采用二叉链表来存储树的每个节点。二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针 指向该结点的两个孩子。

  ```c
  typedef struct BTNode()
  {
  	int data;
  	struct BTNode *lchild;
  	struct BTNode *rchild;
  }BTNode;
  ```

  



### 二叉树的遍历 

二叉树的dfs遍历，递归和非递归，一个是系统栈，一个是用户栈，为什么用户栈比系统栈效率高？

答：递归函数申请的系统栈是一个所有递归函数都要通用的栈，系统栈除了会 记录访问过的节点信息，还有其他信息比如函数参数和返回值等等，以实现函 数的递归调用。

 而用户自己定义的栈仅保存遍历所需的节点信息，是一个有针对性的设计，所 以相比之下更高效。



#### 1、先序遍历：

1. 访问根结点；
2. 先序遍历左子树；
3. 先序遍历右子树。

- 递归

  ```c
  void preorder(BTBode *p)
  {
      if (p != NULL)
      {
          visit(p);
          preorder(p->lchild);
          preorder(p->rchild);
      }
  }
  ```

- 非递归

  1. 根节点入栈

  2. 循环栈：

  ​      1）根节点出栈

  ​      2）右节点入栈

  ​      3）左节点入栈

  ```c
  void perorderNonrecursion (BTNode *bt)
  {
      if (bt != null)
      {
          BTNode * Stack[N];  // 定义一个栈
          int top = -1;  // 初始化栈
          BTNode *p;
          Stack[++ top] = p;
          if (top != -1)
          {
              p = Stack[-- top];
              visit(p);
              if (p -> rchild != null ) Stack[++ top] = p -> rchild;
              if (p -> lchild != null ) Stack[++ top] = p -> lchild;
          }
      }
  }
  ```

  

#### 2、中序遍历：

1. 中序遍历左子树；
2. 访问根结点；
3. 中序遍历右子树。

- 递归

  ```c
  void preorder(BTBode *p)
  {
      if (p != NULL)
      {
          preorder(p->lchild);
          visit(p);
          preorder(p->rchild);
      }
  }
  ```

- 非递归

  1. 根节点入栈

  2. 循环栈：

     1）看栈顶是否有左子，有的话，左子一直入栈

     2）（没有左子）输出栈顶（就是“中”）

     3）再看是否有右子，有则右子入栈，再循环2.1

  ```c
  void inorderNonrecursion (BTNode *bt)
  {
      if (bt != null)
      {
          BTNode * Stack[N];  // 定义一个栈
          int top = -1;  // 初始化栈
          BTNode *p;
          p = bt;
          // 中序遍历
          // 栈不空 或者 指针不空 （循环条件）
          while(top != -1 || p != null)
          {
           	while(p != null)  // 左孩子存在，则左孩子入栈
              {
                  Stack[++ top] = p;
                  p = p -> lchild;
              }
              if (top != -1)  // 栈不空
              {
                  p = Stack[top --];  // 输出栈顶
                  visit(p);  // 访问元素
                  p = p -> rchild;  
              }
          }    
      }
  }
  ```

  

#### 3、后序遍历

1. 后序遍历左子树；
2. 后序遍历右子树；
3. 访问根结点。

- 递归

  ```c
  void preorder(BTBode *p)
  {
      if (p != NULL)
      {
          preorder(p->lchild);
          preorder(p->rchild);
          visit(p);
      }
  }
  ```

- 非递归

  1. 根节点入栈

  2. 循环栈：

     1）看栈顶是否有左子，有的话，左子一直入栈

     2）（没有左子）看右子

     ​		右子入栈，再重复2.1

     。。。有问题



#### 4、层序遍历

若树为空，则什么都不做直接返回。
否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

建立一个队列

1. 根节点入队
2. 出队，访问该节点：
   - 如果有左孩子，左孩子入队
   - 如果有右孩子，右孩子入队



### 线索二叉树

- 二叉树的非递归遍历避免了系统栈的调用，提高了一定的效率。线索二叉树可以把用户栈也省掉，把二叉树的遍历过程线索化，进一步提高效率。

* N个结点的二叉链表，N+1个空指针域。

* 将树中的空指针域作为寻找当前结点前驱或后继的线索。

|         lchild         | ltag | data | rtag |         rchild         |
| :--------------------: | :--: | :--: | :--: | :--------------------: |
|  **指针**，指向左孩子  |  0   |      |  0   |  **指针**，指向右孩子  |
| **线索**，指向前驱结点 |  1   |      |  1   | **线索**，指向后继结点 |



### 二叉树、树、森林的转换

1. 树---》二叉树：

   - 同一节点的各孩子用线连接串起来

   - 将每个结点的分支从左往右除了第一个，其余都剪掉

2. 二叉树---》树：
   - 找到一个孩子节点，然后沿着他一直往右下走
   - 途径的所有的节点都与该孩子的父节点相连；然后断开孩子之间的连线

3. 森林---》二叉树：
   - 先将森林里的每一棵树转为二叉树（树的根节点一定是没有右兄弟的，因此转换为二叉树后，根节点一定没有右孩子）
   - 再将第二棵二叉树转换为第一棵的右子树，以此类推

4. 二叉树---》森林：
   - 将根节点有右孩子的二叉树都断开
   - 再进行二叉树---》树

- 树/森林 的先序遍历 == 二叉树的先序遍历

  树/森林 的后序遍历 == 二叉树的中序遍历



### 哈夫曼树和哈夫曼编码

- **哈夫曼树：又叫最优二叉树。带权路径长度最短。**

  构建哈夫曼树：

  1. 将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。
  2. 构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。
  3. 从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
  4. 重复步骤2）和3），直至F中只剩下一棵树为止。



- **哈夫曼编码：通过哈夫曼树导出的每个字符的编码，进而得到对整个字符串的编码（压缩空间）**

  哈夫曼编码是前缀码，因为根通往任意叶子节点的路径都不可能是通往其余叶子节点路径的子路径

  > 前缀码中：任意字符的编码串都不是另一字符编码串的前缀。
  >
  > 用前缀码，在解码时不会发生歧义

  - 权值：字符出现在字符串里的次数（然后构建哈夫曼树）
  - 对字符的编码：是路径



- **为什么要用哈夫曼树构建前缀码？**

  **答：**由哈夫曼树的特性可知，其树的带权路径长度是最短的。哈夫曼编码的过程中，每个字符的权值是在字符串中出现的次数，路径长度是每个字符编码的长度。字符出现的次数越多，编码长度越短。这样就使得其整个字符串在编码后的前缀码长度最短。

  哈夫曼编码产生的是最短前缀码。





### 图的存储结构

* **邻接矩阵法（顺序存储）（稠密图）**：用一个一维数组存储图的顶点信息，用二维数组存储各顶点的邻接关系。存储顶点邻接关系的二维数组称为邻接矩阵。
* **邻接表法（链式存储）（稀疏图）**：图中每个顶点与其有邻接关系的顶点拉成一个单链表，每个顶点都有一个单链表。
  - 十字链表法（有向图）：十字链表法是有向图的一种链式存储结构。在十字链表中，有向图中的每一条弧都有一个对应的节点，每个顶点都有对应的一个节点。
  - 邻接多重表法（无向图）





### 图的遍历

#### 深度优先遍历

深度优先搜索(DFS:Depth-First-Search)：深度优先搜索类似于树的先序遍历算法

* 空间复杂度：**由于DFS是一个递归算法，递归是需要一个工作栈**来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|)
* 时间复杂度：
  1. 邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)

  2. 邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2) 



#### 广度优先遍历

广度优先搜索(BFS:Breadth-First-Search)：广度优先搜索类似于树的层序遍历算法

* 空间复杂度：**BFS需要借助一个队列**，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    
* 时间复杂度：
  1. 邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)
  2. 邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)





### 图的应用

![](/img/ds/tulun.jpg)

#### 一、最小生成树

#### 1、Prim算法

**与Dijkstra区别：Dijkstra算法是更新到起始点的距离；Prim是更新到集合S的距离 **

- **思路：$O(n ^2)$**
  1. **找集合之外距离最近的点**
  2. **标记这个点(并加入集合)**
  3. **用这个点 $t$ 更新其他点到集合的距离**

* 双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为$O(n ^2)$
  而且时间复杂度只和n有关，所以适合稠密图

![](/img/ds/prim.jpg)





#### 2、Kruskal算法

* **思路：$O(mlogm)$**
  1. **将图中边按照权值从小到大排列**
  2. **然后从最小的边开始枚举。如果该边并入不构成回路的话，将该边并入集合中（当前生成树）。直到所有的边都检测完为止。**
* 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图

![](/img/ds/kruskal.jpg)



#### 二、最短路径

#### 1、Dijkstra算法

* **单源最短路：一个源点到其余顶点的最短路径**

![](/img/ds/朴素dijkstra.jpg)



#### 2、弗洛伊德

* **多源汇最短路：所有顶点到所有顶点的最短路径（询问从i->j的最短路）**
  * 算法思想：
    递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)
    其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径
  * 非带权图
* 两点之间经过边数最少的路径
  * 带权图
* 两点之间经过的边上权值之和最小的路径





### 拓扑排序

- 拓扑排序常用来确定一个依赖关系集中，事物发生的顺序。例如，在日常工作中，可能会将项目拆分成A、B、C、D四个子部分来完成，但A依赖于B和D，C依赖于D。为了计算这个项目进行的顺序，可对这个关系集进行拓扑排序，得出一个线性的序列，则排在前面的任务就是需要先完成的任务。

* AOV(Activity On Vertex)

* 如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)

* 拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：
  如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；
  如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。

* **拓扑排序算法：**
  从AOV网中**选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧**。重复这个步骤<u>直到输出图中全部顶点，或者找不到入度为0的顶点为止。</u>

* **拓扑排序流程(bfs)：**

  1. **遍历所有点找到入度为0的点，把它们入队**

  2. **开始从入度为0的点 找：**

     1. **队头出队**
     2. **遍历队头的临边**
     3. **临边的入度 - 1** 

     4. **判断此时入度是否为0：为0说明它可以做新的起点，入队**

  3. **return tt == n - 1 (队尾下标是n-1，说明所有点都已经入队)**.



### AOV与AOE的区别？

相同点：AOV网和AOE网都是有向无环图，<u>区别在于它们的顶点和边所代表的含义是不同的</u>：

- AOV网的顶点：活动，边：仅代表活动之间的关系，无权值。
- AOE网的顶点：事件，边：表示活动，边有权值，表示完成该活动所需要的时间。

**关键路径**

* AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。



#### 

### 查找

- 静态查找：若一个查找表的操作无需动态的修改表，称为静态查找。
- 动态查找：需要动态的插入和删除的查找表称为动态查找表。
- 平均查找长度：所有查找过程中进行关键字比较次数的平均值。





### 顺序查找

从线性表的一端开始，逐个比较关键字的值是否满足查询条件。

- 优点：对数据元素的存储没有要求，顺序存储或链式存储均可。
- 缺点：平均查找长度大，效率低。



### 折半查找

若顺序表有序，先将关键字与表中间元素比较，若相等则查找成功，否则在除中间元素以外的前半部分或后半部分进行同样的查找，如此重复直到查找成功或者确定表中没有要查找的元素，查找失败。

- 优点：比顺序查找效率高
- 缺点：查找表必须有序且必须采用顺序存储结构。





### 分块查找

将查找表分为若干个子块，块内元素可以无序，各块之间必须有序，也就是说，第一个块内最大的关键字要小于第二个块内所有记录的关键字，第二个块内最大的关键字要小于第三个块内所有记录的关键字以此类推，再建立一张索引表，表项中存放每个块的最大关键字和第一个元素的地址。
查找步骤为：

1. 在索引表中确定待查记录所在的块，可以顺序查找也可以折半查找。
2. 在块内顺序查找。

<u>吸取了顺序查找和折半查找各自的优点。</u>



### 散列表

散列函数：一个把查找表中关键字映射成为该关键字对应地址的函数。Hash(key)=Addr

散列表：根据关键字直接进行访问的散列表，建立了关键字与存储地址的直接映射关系。

- 散列函数的构造方法：(开除平)

1. **开放定址法**：直接取关键字的某个线性函数值为其存储地址。H(key)=a×key+b
2. **除留余数法**：假定散列表表长为m，取一个不大于m且最接近m的质数p，通过关键字取余p来得到关键字的存储地址。
3. **平方取中法**：取关键字平方的中间几位作为该关键字的存储地址。

- 解决冲突的办法：(线平双)

1. **开放地址法**：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。

   1. <u>线性探测法</u>：冲突发生时顺序查看表中下一个单元，直到找出一个空闲单元为止。（可能会造成大量元素在相邻的散列地址上堆积，降低查找效率）

   2. <u>平方探测法</u>：设发生冲突的地址为d,平方探测法得到的新的地址序列为$(d+1)^2$，$(d-1)^2$，$(d+2)^2$，$(d-2)^2$......

      能够避免出现”堆积问题“，但是不能够探测到散列表中的所有单元。

   3. <u>双散列法</u>：使用两个散列函数，当第一个散列函数出现冲突时，就选用第二个散列函数。

2. **拉链法**：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非 同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表 由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。



散列表的查找性能：和装填因子有关。α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突 的可能性越小



### 排序

- 内部排序：排序期间元素全部存放在内存中。（插入，交换，选择，归并，基数）

- 外部排序：排序期间元素无法同时存放在内存中，必须在排序期间根据要求不停地在内，外存移动。（多路归并）

- 排序的稳定性：如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。



### 插入排序

- **直接插入排序**：每次将一个待排序的记录按其关键字的大小插入到已排好序的子序列中。

  1. 从前面的有序子表中查出待插入元素应该插入的位置

  2. 将已排序的记录逐步向后移动，给待插入元素腾出位置，并将待插入元素复制到插入位置。 

     适用顺序存储/链式存储

- **折半插入排序**：如果是顺序存储的线性表，可以通过折半查找的方式来查找待插入元素在有序子序列的位置。确定待插入位置之后，可以统一的向后移动位置。

- **希尔排序**：将待排序列按相隔某个增量分割成若干个子序列，对各个子序列进行直接插入排序，逐渐缩小增量，重复上述步骤，直到序列基本有序，再对全体记录进行一次直接插入排序。



### 交换排序

- **冒泡排序**：从前到后（从后往前）依次两两比较相邻元素的值，若为逆序，就交换元素，每一趟排序完成之后，就有一个元素被放在最终位置上，重复上述步骤，当一趟排序不发生任何元素的交换为止。

- **快速排序**：快速排序是一种基于分治法的排序方法。 

  每一趟快排选择序列中任一个元素作为枢轴(通常选第一个元素)，将序列中比枢 轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。最后确定枢轴元素的最终位置并将枢轴放入，再对枢轴前后得到的子序列再重复上述步骤，直到每部分只有一个元素或为空为止，则所有元素放在最终位置上。

  * 时间复杂度：
    最好情况下时间复杂度为$O(nlogn)$，待排序序列越无序，算法效率越高。
    最坏情况下时间复杂度为$O(n^2)$，待排序序列越有序，算法效率越低。

  * 空间复杂度：
    由于快速排序是递归的，需要借助一个**递归工作栈**来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。
    最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)
    最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；

  * 稳定性：快速排序是不稳定的，是因为存在交换关键字。





### 选择排序

- **简单选择排序**：每趟排序选择关键字最小的元素与序列前面的元素进行交换，每次排序均可确定一个元素的最终位置。

- **堆排序**：先将待排元素建成初始堆，以大根堆为例，堆顶元素为最大值，将其输出后，把堆底元素送入堆顶，此时堆不满足大根堆的性质，将堆顶元素向下调整（从堆的最后一个非叶子节点开始，从左到右，从下到上的顺序进行调整），成为大根堆之后再输出堆顶元素，重复上述过程，直到输出所有元素。

  * 什么是堆？

    * 堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。
      * 如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。
      * 如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。

  * 什么是堆排序？

    * 我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。

    * 时间复杂度：
      堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆

      堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)

     * 堆排序不稳定





### 归并排序

“归并”：就是将两个或两个以上的有序表组成一个新的有序表。

归并排序是分治的思想。先将整个序列分为两半，对每一半分别进行排序，得 到两个有序序列，再将两个序列归并成一个序列即可。

>  假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1， 然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重 复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。

稳定性：稳定

![](/img/ds/归并快排.jpg)

可以发现，**归并排序的处理过程是由下到上的**，先处理子问题，然后再合并。而**快排正好相反，它的处理过程是由上到下的**，先分区，然后再处理子问题。**归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法**。我们前面讲过，归并之所以是非原地排序算法，主要原因是**合并函数无法在原地执行**。**快速排序通过设计**巧妙的原地分区函数，**可以实现原地排序。**





### 基数排序

* 基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。
* 创建0~9的十个数组，将待排序表的所有元素先按个位进行分类，将分类后的元素按索引大小取出形成新的队列，再对队列按十位，百位的顺序进行分类，重复上述过程，最后形成一个有序序列。
* 例子：53, 3, 542, 748, 14, 214, 154, 63, 616
  * 补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616
  * 桶实际是一个队列，先进先出(从桶的上面进，下面出)
  * 关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10
* 空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)
* 时间复杂度：需要进行关键字位数d次"分配"和"收集"，一次"分配"需要将n个关键字放进各个队列中，一次"收集"需要将r个桶都收集一遍。所以一次"分配"和一次"收集"时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。
* 稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。





### 选取排序算法需要考虑的因素

1. 待排元素的数目；
2. 稳定性的要求；
3. 元素本身信息量的大小；
4. 关键字的结构及其分布情况；

若n较小，可直接采用直接插入排序或者简单选择排序。由于直接插入排序比简单选择排序移动的元素要多，所以当元素本身信息量比较大时可选用简单选择排序。
若待排序表已基本有序可以选用直接插入排序或者冒泡排序。

当n比较大时，可以选用快速排序、堆排序、归并排序。快速排序被认为是当前基于比较的内部排序中最好的排序方法，当待排序表记录随机分布时，使用快速排序速度最快。堆排序所用存储空间少于快速排序，且不会出现快速排序的最坏情况，这两种算法都是不稳定的，若要稳定排序则选用归并排序算法。





### 外部排序

采用多路归并法，包括两个相对独立的阶段：
（1）根据内部缓冲区的大小，将待排文件分成若干个大小合适的子文件，将子文件带入内存采用内部排序算法排序完成后再写回外存。
（2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直到得到整个有序文件为止。





### 提高外部排序算法的效率

由于待排文件无法全部放入内存，所以排序期间必须要频繁的进行内外存之间数据的交换，这会耗费大量的时间。所以可以通过增加归并路数来减少归并趟数，进而减少I/O次数。而增加归并路数又会增加内部排序的时间，所以引入了败者树。
增加初始归并段个数，并且不受内存空间的限制，引入了置换-选择算法。
文件经过置换-选择算法之后得到的是长度不同的初始归并段，如何组织长度不等的出使归并段的归并顺序，使得I/O次数最少，就引入了最佳归并树。





### 败者树（大的为失败者，小的为胜利者）

可视为一棵完全二叉树，每个叶结点存放各归并段在归并过程中参加比较的记录，非叶结点用来记录左右子树中的“失败者”，胜利者继续向上比较直到根节点。输出最后的胜利者。





### 置换选择算法

根据缓冲区的大小，由外存读入记录，当记录充满缓冲区时，选择最小的输出，其空缺位置由下一个记录来取代，输出记录称为当前初始归并段的一部分，如果新输出的记录比新建立归并段最大的记录小，就不能成为该归并段的一部分，只能成为下一个归并段的选择。重复上述步骤，直到缓冲区中所有记录都比当前归并段最大记录小时，就生成了一个初始归并段，用同样的方法继续生成下一个归并段，直到全部记录都处理完毕为止。





### 最佳归并树

对于K路归并算法，可用构造K叉哈夫曼树的方法来构造最佳归并树。



